<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üß¨ DNA Music Ball - Leo 10s</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            z-index: 200;
            pointer-events: none;
        }
        #title {
            font-size: 42px;
            font-weight: bold;
            text-shadow: 0 0 20px cyan;
            animation: pulse 2s infinite;
        }
        #stats {
            font-size: 16px;
            color: #ffff00;
            margin-top: 10px;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            text-align: center;
        }
        button {
            background: linear-gradient(135deg, #00ffff, #00cccc);
            color: #000;
            border: none;
            padding: 15px 30px;
            margin: 5px;
            cursor: pointer;
            border-radius: 8px;
            font-weight: bold;
            font-size: 18px;
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.4);
        }
        button:hover { transform: translateY(-2px); }
        button.active { background: linear-gradient(135deg, #00ff00, #00cc00); }
    </style>
</head>
<body>
    <div id="info">
        <div id="title">üß¨ DNA MUSIC BALL</div>
        <div id="stats">Chargement...</div>
    </div>
    
    <div id="controls">
        <button id="audioBtn">üîä Activer Son</button>
        <button id="dropBtn" disabled>‚ñ∂Ô∏è DROP</button>
        <button id="resetBtn">‚Üª RESET</button>
        <button id="viewBtn">üëÅÔ∏è Vue DNA</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ========== WEB AUDIO API ==========
        let audioContext = null;
        let masterGain = null;
        let audioEnabled = false;

        function midiToFreq(note) {
            return 440 * Math.pow(2, (note - 69) / 12);
        }

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioContext.createGain();
                masterGain.gain.value = 0.6;
                masterGain.connect(audioContext.destination);
            }
            
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            audioEnabled = true;
            document.getElementById('audioBtn').textContent = 'üîä Son ON';
            document.getElementById('audioBtn').classList.add('active');
            document.getElementById('dropBtn').disabled = false;
        }

        function playNote(midiNote, duration = 0.4, velocity = 1.0) {
            if (!audioEnabled || !audioContext) return;
            
            const freq = midiToFreq(midiNote);
            const now = audioContext.currentTime;
            
            const osc = audioContext.createOscillator();
            osc.type = 'triangle';
            osc.frequency.value = freq;
            
            const noteGain = audioContext.createGain();
            noteGain.gain.value = 0;
            noteGain.gain.linearRampToValueAtTime(velocity * 0.7, now + 0.01);
            noteGain.gain.exponentialRampToValueAtTime(velocity * 0.3, now + 0.08);
            noteGain.gain.exponentialRampToValueAtTime(0.01, now + duration);
            
            osc.connect(noteGain);
            noteGain.connect(masterGain);
            
            osc.start(now);
            osc.stop(now + duration);
        }

        // ========== THREE.JS SCENE ==========
        const scene = new THREE.Scene();
        
        // Gradient background (plus clair pour voir les structures)
        const canvas = document.createElement('canvas');
        canvas.width = 2;
        canvas.height = 256;
        const ctx2d = canvas.getContext('2d');
        const gradient = ctx2d.createLinearGradient(0, 0, 0, 256);
        gradient.addColorStop(0, '#1a1a3e'); // Bleu fonc√© en haut
        gradient.addColorStop(0.5, '#2a2a4e'); // Bleu moyen
        gradient.addColorStop(1, '#0a0a2e'); // Noir-bleu en bas
        ctx2d.fillStyle = gradient;
        ctx2d.fillRect(0, 0, 2, 256);
        const bgTexture = new THREE.CanvasTexture(canvas);
        scene.background = bgTexture;
        
        scene.fog = new THREE.Fog(0x1a1a3e, 40, 100);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.set(0, 15, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        // Post-processing
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        composer.addPass(new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            2.5, 0.6, 0.85
        ));

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxDistance = 50;
        controls.minDistance = 5;

        // Lighting - Plus lumineux pour voir les structures
        scene.add(new THREE.AmbientLight(0x404060, 1.2));
        
        const keyLight = new THREE.DirectionalLight(0xffffff, 1.5);
        keyLight.position.set(10, 20, 10);
        keyLight.castShadow = true;
        keyLight.shadow.mapSize.width = 2048;
        keyLight.shadow.mapSize.height = 2048;
        scene.add(keyLight);
        
        // Fill light pour √©clairer les c√¥t√©s
        const fillLight = new THREE.DirectionalLight(0x6666ff, 0.6);
        fillLight.position.set(-10, 10, -10);
        scene.add(fillLight);
        
        // Rim light pour contours
        const rimLight = new THREE.DirectionalLight(0xff66ff, 0.4);
        rimLight.position.set(0, -10, 5);
        scene.add(rimLight);

        // ========== PHYSICS ==========
        const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.8, 0) });  // Gravit√© r√©aliste
        const platformMaterial = new CANNON.Material('platform');
        const ballMaterial = new CANNON.Material('ball');
        const contact = new CANNON.ContactMaterial(platformMaterial, ballMaterial, {
            friction: 0.1,
            restitution: 0.3  // Peu de rebond pour glisser
        });
        world.addContactMaterial(contact);

        // ========== BALL - Plus visible ==========
        const bubbleGeom = new THREE.SphereGeometry(0.6, 32, 32);
        const bubbleMat = new THREE.MeshPhysicalMaterial({
            color: 0x00ffff,
            emissive: 0x00ffff,
            emissiveIntensity: 0.6,
            transmission: 0.7,
            opacity: 0.8,
            metalness: 0.3,
            roughness: 0.2,
            transparent: true
        });
        const bubbleMesh = new THREE.Mesh(bubbleGeom, bubbleMat);
        scene.add(bubbleMesh);
        
        // Anneau externe pour mieux voir la boule
        const ringGeom = new THREE.TorusGeometry(0.7, 0.08, 16, 32);
        const ringMat = new THREE.MeshStandardMaterial({
            color: 0xffff00,
            emissive: 0xffff00,
            emissiveIntensity: 1.0
        });
        const ringMesh = new THREE.Mesh(ringGeom, ringMat);
        ringMesh.rotation.x = Math.PI / 2;
        scene.add(ringMesh);

        const ballBody = new CANNON.Body({
            mass: 1,
            shape: new CANNON.Sphere(0.6),
            material: ballMaterial,
            linearDamping: 0.2,    // Amortissement pour contr√¥ler vitesse
            angularDamping: 0.1
        });
        world.addBody(ballBody);

        const ballLight = new THREE.PointLight(0x00ffff, 8, 15);
        scene.add(ballLight);
        
        // Spotlight qui suit la boule
        const spotLight = new THREE.SpotLight(0xffffff, 2.0, 20, Math.PI / 6, 0.5);
        spotLight.position.set(0, 10, 0);
        scene.add(spotLight);
        scene.add(spotLight.target);

        // ========== LOAD DNA DATA ==========
        let platforms = [];
        let platformBodies = [];
        let platformLights = [];
        let dnaData = null;
        let collisionHistory = new Set();
        let notesPlayed = 0;

        async function loadDNAData() {
            try {
                const response = await fetch('data/leo_10s_wall.json');
                dnaData = await response.json();
                
                console.log('üß¨ DNA Data loaded:', dnaData.metadata);
                console.log('Platforms:', dnaData.platforms.length);
                
                // analysis est optionnel (DNA a climaxIndex, guaranteed path non)
                if (dnaData.analysis?.climaxIndex !== undefined) {
                    console.log('Climax:', dnaData.analysis.climaxIndex);
                }
                
                createDNAPlatforms();
                createWallSegments();  // Cr√©er le mur !
                
                const pathType = dnaData.metadata.generator?.includes('WALL') ? 'Mur Inclin√©' : 
                                dnaData.metadata.generator?.includes('GUARANTEED') ? 'Chemin Garanti' : 'ADN Musical';
                document.getElementById('stats').textContent = 
                    `${dnaData.platforms.length} plateformes | ${pathType}`;
                
                return true;
            } catch (error) {
                console.error('Error loading DNA:', error);
                document.getElementById('stats').textContent = 'Erreur chargement DNA';
                return false;
            }
        }

        function createDNAPlatforms() {
            // Clear existing
            platforms.forEach(p => scene.remove(p));
            platformLights.forEach(l => scene.remove(l));
            platformBodies.forEach(b => world.removeBody(b));
            platforms = [];
            platformLights = [];
            platformBodies = [];

            dnaData.platforms.forEach((data, i) => {
                const x = parseFloat(data.x);
                const y = parseFloat(data.y);
                const z = parseFloat(data.z);
                const size = parseFloat(data.size);
                const colorHex = parseInt(data.color);

                // Visual mesh
                let geometry;
                switch(data.type) {
                    case 'circle':
                        geometry = new THREE.CylinderGeometry(size * 0.8, size * 0.8, 0.25, 16);
                        break;
                    case 'star':
                        geometry = new THREE.CylinderGeometry(size * 0.6, size * 0.6, 0.3, 5);
                        break;
                    case 'tube':
                        geometry = new THREE.CylinderGeometry(size * 0.5, size * 0.5, 0.2, 16);
                        break;
                    case 'halfPipe':
                        geometry = new THREE.CylinderGeometry(size * 1.2, size * 1.2, 0.3, 12, 1, true, 0, Math.PI);
                        break;
                    default:
                        geometry = new THREE.BoxGeometry(size * 1.5, 0.25, size * 1.2);
                }

                const material = new THREE.MeshStandardMaterial({
                    color: colorHex,
                    emissive: colorHex,
                    emissiveIntensity: 0.7,
                    metalness: 0.5,
                    roughness: 0.3,
                    transparent: true,
                    opacity: 0.9
                });
                
                // Wireframe pour voir la structure
                const wireframeGeo = geometry.clone();
                const wireframeMat = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    wireframe: true,
                    opacity: 0.3,
                    transparent: true
                });
                const wireframe = new THREE.Mesh(wireframeGeo, wireframeMat);

                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, z);
                mesh.rotation.x = Math.PI / 2; // Horizontal
                mesh.castShadow = true;
                mesh.userData.midiNote = data.midiNote || data.note?.pitch;
                mesh.userData.platformIndex = i;
                scene.add(mesh);
                platforms.push(mesh);
                
                // Add wireframe
                wireframe.position.copy(mesh.position);
                wireframe.rotation.copy(mesh.rotation);
                wireframe.visible = false; // Toggle avec bouton
                scene.add(wireframe);
                mesh.userData.wireframe = wireframe;

                // Light - Plus intense
                const light = new THREE.PointLight(colorHex, 3.5, 8);
                light.position.set(x, y, z - 1);
                scene.add(light);
                platformLights.push(light);
                
                // Helper pour voir la structure (petit sphere)
                const helperGeom = new THREE.SphereGeometry(0.15, 8, 8);
                const helperMat = new THREE.MeshBasicMaterial({ 
                    color: colorHex,
                    transparent: true,
                    opacity: 0.5
                });
                const helper = new THREE.Mesh(helperGeom, helperMat);
                helper.position.set(x, y, z);
                scene.add(helper);

                // Physics body
                let physicsShape;
                if (data.type === 'halfPipe') {
                    physicsShape = new CANNON.Box(new CANNON.Vec3(size * 1.2, 0.125, size * 1.2));
                } else {
                    physicsShape = new CANNON.Cylinder(size * 0.8, size * 0.8, 0.25, 16);
                }

                const body = new CANNON.Body({ mass: 0, material: platformMaterial });
                body.addShape(physicsShape);
                body.position.set(x, y, z);
                body.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2);
                body.userData = { platformIndex: i };
                world.addBody(body);
                platformBodies.push(body);
            });

            console.log(`‚úì Created ${platforms.length} DNA platforms`);
        }

        // Collision detection
        ballBody.addEventListener('collide', (event) => {
            const contactBody = event.body;
            if (contactBody.userData && contactBody.userData.platformIndex !== undefined) {
                const idx = contactBody.userData.platformIndex;
                
                if (collisionHistory.has(idx)) return;
                collisionHistory.add(idx);
                setTimeout(() => collisionHistory.delete(idx), 250);
                
                const platform = platforms[idx];
                const data = dnaData.platforms[idx];
                const note = data.midiNote || data.note?.pitch;
                const velocity = Math.min(Math.abs(event.contact.getImpactVelocityAlongNormal()) / 15, 1.0);
                
                playNote(note, 0.5, velocity);
                
                platformLights[idx].intensity = 6;
                setTimeout(() => { platformLights[idx].intensity = 2; }, 150);
                
                notesPlayed++;
                document.getElementById('stats').textContent = 
                    `Note ${notesPlayed}/${dnaData.platforms.length} | Pitch: ${note}`;
                
                const noteTime = data.time || data.note?.time || 0;
                console.log(`üéµ [${idx}] Note ${note} - time: ${noteTime}s`);
            }
        });

        // ========== CREATE WALL SEGMENTS ==========
        const wallBodies = [];
        const wallMeshes = [];
        
        function createWallSegments() {
            if (!dnaData.wallSegments) return;
            
            // Clear existing walls
            wallMeshes.forEach(m => scene.remove(m));
            wallBodies.forEach(b => world.removeBody(b));
            wallMeshes.length = 0;
            wallBodies.length = 0;
            
            const wallMaterial = new CANNON.Material('wall');
            const wallContact = new CANNON.ContactMaterial(ballMaterial, wallMaterial, {
                friction: dnaData.metadata.physics?.wallFriction || 0.4,
                restitution: dnaData.metadata.physics?.restitution || 0.3
            });
            world.addContactMaterial(wallContact);
            
            dnaData.wallSegments.forEach((seg, i) => {
                // Calculate dimensions
                const dx = seg.end.x - seg.start.x;
                const dy = seg.end.y - seg.start.y;
                const dz = seg.end.z - seg.start.z;
                const length = Math.sqrt(dx*dx + dy*dy + dz*dz);
                
                const midX = (seg.start.x + seg.end.x) / 2;
                const midY = (seg.start.y + seg.end.y) / 2;
                const midZ = (seg.start.z + seg.end.z) / 2;
                
                // Visual mesh - large transparent wall
                const geometry = new THREE.BoxGeometry(seg.width, seg.thickness, length);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x2a2a4e,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const mesh = new THREE.Mesh(geometry, material);
                
                // Position and rotate
                mesh.position.set(midX, midY, midZ);
                
                // Rotation to align with segment
                const angle = Math.atan2(dz, dy);
                mesh.rotation.x = angle;
                
                scene.add(mesh);
                wallMeshes.push(mesh);
                
                // Physics body
                const shape = new CANNON.Box(new CANNON.Vec3(seg.width/2, seg.thickness/2, length/2));
                const body = new CANNON.Body({ mass: 0, material: wallMaterial });
                body.addShape(shape);
                body.position.set(midX, midY, midZ);
                body.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), angle);
                world.addBody(body);
                wallBodies.push(body);
            });
            
            console.log(`‚úì ${wallBodies.length} segments de mur cr√©√©s`);
        }

        function resetBall() {
            if (!dnaData || platforms.length === 0) return;
            
            // Utiliser ballStart du metadata si disponible
            const ballStart = dnaData.metadata?.ballStart;
            if (ballStart) {
                ballBody.position.set(ballStart.x, ballStart.y, ballStart.z);
                ballBody.velocity.set(
                    ballStart.velocity.x,
                    ballStart.velocity.y,
                    ballStart.velocity.z
                );
                console.log(`Reset: ball at (${ballStart.x}, ${ballStart.y}, ${ballStart.z})`);
                console.log(`Velocity: (${ballStart.velocity.x}, ${ballStart.velocity.y}, ${ballStart.velocity.z})`);
            } else {
                // Fallback: premi√®re plateforme + 3 unit√©s de hauteur
                const firstPlatform = dnaData.platforms[0];
                const x = parseFloat(firstPlatform.x);
                const y = parseFloat(firstPlatform.y) + 3;
                const z = parseFloat(firstPlatform.z);
                ballBody.position.set(x, y, z);
                ballBody.velocity.set(1.5, 0, 0);
                console.log(`Reset: ball at (${x}, ${y}, ${z}) [fallback]`);
            }
            
            ballBody.angularVelocity.set(0, 0, 0);
            collisionHistory.clear();
            notesPlayed = 0;
        }

        // ========== CONTROLS ==========
        let gameRunning = false;
        let dnaView = false;

        document.getElementById('audioBtn').addEventListener('click', initAudio);
        
        document.getElementById('dropBtn').addEventListener('click', () => {
            gameRunning = true;
            resetBall();
        });
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            gameRunning = false;
            resetBall();
        });

        document.getElementById('viewBtn').addEventListener('click', () => {
            dnaView = !dnaView;
            if (dnaView) {
                camera.position.set(0, 30, 0);
                camera.lookAt(0, 0, 0);
                document.getElementById('viewBtn').textContent = 'üé¨ Vue Jeu';
                // Montrer les wireframes en vue DNA
                platforms.forEach(p => {
                    if (p.userData.wireframe) p.userData.wireframe.visible = true;
                });
            } else {
                camera.position.set(0, 15, 20);
                camera.lookAt(0, 10, 0);
                document.getElementById('viewBtn').textContent = 'üëÅÔ∏è Vue DNA';
                // Cacher les wireframes en vue jeu
                platforms.forEach(p => {
                    if (p.userData.wireframe) p.userData.wireframe.visible = false;
                });
            }
        });

        // ========== ANIMATION LOOP ==========
        const fixedTimeStep = 1 / 60;
        let lastTime = performance.now() / 1000;

        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = performance.now() / 1000;
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            if (gameRunning) {
                world.step(fixedTimeStep, deltaTime, 3);
                
                bubbleMesh.position.copy(ballBody.position);
                ringMesh.position.copy(ballBody.position);
                ringMesh.rotation.z += 0.05; // Rotation pour effet visuel
                ballLight.position.copy(ballBody.position);
                spotLight.target.position.copy(ballBody.position);
                
                if (!dnaView) {
                    // Cam√©ra suit VRAIMENT la boule
                    const targetPos = new THREE.Vector3(
                        ballBody.position.x - 5,
                        ballBody.position.y + 3,
                        ballBody.position.z + 8
                    );
                    camera.position.lerp(targetPos, 0.08);
                    camera.lookAt(ballBody.position);
                }
            }
            
            controls.update();
            composer.render();
        }

        // ========== INIT ==========
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // Load DNA and start
        loadDNAData().then(success => {
            if (success) {
                resetBall();
                animate();
            }
        });
    </script>
</body>
</html>
