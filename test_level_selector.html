<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Level Selector - Physics Test</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #0a0a0a; 
            font-family: Arial, sans-serif;
        }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            max-width: 300px;
        }
        #selector {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 8px;
            color: white;
        }
        #selector h3 {
            margin: 0 0 10px 0;
            color: #ffc356;
        }
        #selector button {
            display: block;
            width: 100%;
            background: #ffc356;
            border: none;
            padding: 12px;
            margin: 5px 0;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 13px;
        }
        #selector button:hover { background: #ffdd88; }
        #selector button.active { background: #ff8800; color: white; }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 8px;
        }
        button {
            background: #ffc356;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
        }
        button:hover { background: #ffdd88; }
    </style>
</head>
<body>
    <div id="info">
        <strong>âš½ Level Physics Test</strong><br>
        <span id="levelName">Loading...</span><br>
        <span id="status">Chargement...</span><br>
        <span id="physics">Physics: OFF</span>
    </div>
    
    <div id="selector">
        <h3>ðŸŽ® Choose Level</h3>
        <button data-level="spiral_v2">ðŸŒ€ Spiral v2 NEW</button>
        <button data-level="spiral_descent">ðŸŒ€ Spiral v1</button>
        <button data-level="zigzag_cascade">âš¡ Zigzag Cascade</button>
        <button data-level="wave_parkour">ðŸŒŠ Wave Parkour</button>
    </div>
    
    <div id="controls">
        <button id="dropBall">ðŸ’¥ Drop Ball</button>
        <button id="launch">ðŸš€ Launch</button>
        <button id="reset">ðŸ”„ Reset</button>
    </div>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const CANNON = await import('https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js');

        const status = document.getElementById('status');
        const physicsStatus = document.getElementById('physics');
        const levelNameEl = document.getElementById('levelName');

        const levels = {
            spiral_descent: { name: 'ðŸŒ€ Spiral v1 (solid)', file: 'assets/spiral_descent_level.glb' },
            spiral_v2: { name: 'ðŸŒ€ Spiral v2 (separated)', file: 'assets/spiral_v2_level.glb' },
            zigzag_cascade: { name: 'âš¡ Zigzag Cascade', file: 'assets/zigzag_cascade_level.glb' },
            wave_parkour: { name: 'ðŸŒŠ Wave Parkour', file: 'assets/wave_parkour_level.glb' }
        };

        let currentLevel = 'spiral_descent';
        let scene, camera, renderer, world, ball, ballBody, controls;
        let levelCenter = new THREE.Vector3(0, 0, 0);
        let physicsBodies = [];
        let debugMeshes = [];
        let levelLoaded = false;

        // Scene setup
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            camera = new THREE.PerspectiveCamera(50, 1080 / 1920, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(540, 960);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Physics
            world = new CANNON.World();
            world.gravity.set(0, -15, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;
            
            const bouncyMaterial = new CANNON.Material('bouncy');
            const bouncyContact = new CANNON.ContactMaterial(bouncyMaterial, bouncyMaterial, {
                friction: 0.3,
                restitution: 0.7
            });
            world.addContactMaterial(bouncyContact);
            window.bouncyMaterial = bouncyMaterial;

            // Lights
            const keyLight = new THREE.DirectionalLight(0xffeebb, 3);
            keyLight.position.set(6, 15, -10);
            keyLight.castShadow = true;
            scene.add(keyLight);

            const rimLight = new THREE.DirectionalLight(0xffcc66, 2);
            rimLight.position.set(-8, 12, -8);
            scene.add(rimLight);

            const ambient = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambient);

            // Ball
            const ballRadius = 0.3; // Reduced from 0.7
            const ballGeometry = new THREE.SphereGeometry(ballRadius, 32, 32);
            const ballMaterial = new THREE.MeshStandardMaterial({
                color: 0xffc356,
                metalness: 1.0,
                roughness: 0.05,
                emissive: 0x664400,
                emissiveIntensity: 0.3
            });
            ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.castShadow = true;
            scene.add(ball);

            const ballShape = new CANNON.Sphere(ballRadius);
            ballBody = new CANNON.Body({
                mass: 1,
                shape: ballShape,
                material: window.bouncyMaterial,
                linearDamping: 0.1,
                angularDamping: 0.3
            });
            world.addBody(ballBody);
        }

        function clearLevel() {
            // Remove physics bodies
            physicsBodies.forEach(body => world.removeBody(body));
            physicsBodies = [];
            
            // Remove debug meshes
            debugMeshes.forEach(mesh => scene.remove(mesh));
            debugMeshes = [];
            
            // Remove level objects
            const objectsToRemove = [];
            scene.traverse(obj => {
                if (obj !== ball && obj.type === 'Mesh' && obj !== renderer.domElement) {
                    objectsToRemove.push(obj);
                }
            });
            objectsToRemove.forEach(obj => scene.remove(obj));
            
            levelLoaded = false;
        }

        function loadLevel(levelKey) {
            clearLevel();
            
            currentLevel = levelKey;
            const levelData = levels[levelKey];
            levelNameEl.textContent = levelData.name;
            status.textContent = 'Loading...';
            
            document.querySelectorAll('#selector button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.level === levelKey);
            });

            const loader = new GLTFLoader();
            loader.load(
                levelData.file,
                (gltf) => {
                    const level = gltf.scene;
                    
                    level.traverse((node) => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    
                    scene.add(level);
                    
                    const box = new THREE.Box3().setFromObject(level);
                    box.getCenter(levelCenter);
                    const size = new THREE.Vector3();
                    box.getSize(size);
                    
                    // Create physics bodies
                    level.traverse((node) => {
                        if (node.isMesh && node.geometry) {
                            const geo = node.geometry;
                            geo.computeBoundingBox();
                            
                            if (!geo.boundingBox) return;
                            
                            const localSize = new THREE.Vector3();
                            geo.boundingBox.getSize(localSize);
                            const localCenter = new THREE.Vector3();
                            geo.boundingBox.getCenter(localCenter);
                            
                            const worldCenter = localCenter.clone();
                            node.localToWorld(worldCenter);
                            
                            if (localSize.x > 0.5 && localSize.z > 0.5) {
                                const shape = new CANNON.Box(new CANNON.Vec3(
                                    localSize.x / 2,
                                    localSize.y / 2,
                                    localSize.z / 2
                                ));
                                
                                const body = new CANNON.Body({
                                    mass: 0,
                                    shape: shape,
                                    material: window.bouncyMaterial
                                });
                                
                                body.position.set(worldCenter.x, worldCenter.y, worldCenter.z);
                                
                                const worldQuat = new THREE.Quaternion();
                                node.getWorldQuaternion(worldQuat);
                                body.quaternion.set(worldQuat.x, worldQuat.y, worldQuat.z, worldQuat.w);
                                
                                world.addBody(body);
                                physicsBodies.push(body);
                                
                                // Debug wireframe
                                const debugGeo = new THREE.BoxGeometry(localSize.x, localSize.y, localSize.z);
                                const debugMat = new THREE.MeshBasicMaterial({
                                    color: 0x00ff00,
                                    wireframe: true,
                                    transparent: true,
                                    opacity: 0.2
                                });
                                const debugMesh = new THREE.Mesh(debugGeo, debugMat);
                                debugMesh.position.copy(worldCenter);
                                debugMesh.quaternion.copy(worldQuat);
                                scene.add(debugMesh);
                                debugMeshes.push(debugMesh);
                            }
                        }
                    });
                    
                    // Ground plane
                    const groundShape = new CANNON.Plane();
                    const groundBody = new CANNON.Body({
                        mass: 0,
                        shape: groundShape,
                        material: window.bouncyMaterial
                    });
                    groundBody.position.set(0, box.min.y - 1, 0);
                    groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
                    world.addBody(groundBody);
                    physicsBodies.push(groundBody);
                    
                    // Position ball
                    ballBody.position.set(levelCenter.x, levelCenter.y + 8, levelCenter.z);
                    ballBody.velocity.set(0, 0, 0);
                    ball.position.copy(ballBody.position);
                    
                    // Camera
                    camera.position.set(levelCenter.x + 8, levelCenter.y + 8, levelCenter.z - 10);
                    camera.lookAt(levelCenter);
                    
                    if (controls) controls.dispose();
                    controls = new OrbitControls(camera, renderer.domElement);
                    controls.target.copy(levelCenter);
                    controls.update();
                    
                    levelLoaded = true;
                    status.innerHTML = `âœ“ ${physicsBodies.length} platforms`;
                    physicsStatus.textContent = `Physics: ${physicsBodies.length} bodies`;
                },
                undefined,
                (error) => {
                    status.innerHTML = `âŒ Error`;
                    console.error(error);
                }
            );
        }

        // Controls
        document.getElementById('dropBall').addEventListener('click', () => {
            ballBody.position.set(levelCenter.x, levelCenter.y + 10, levelCenter.z);
            ballBody.velocity.set(0, 0, 0);
            ballBody.angularVelocity.set(0, 0, 0);
        });

        document.getElementById('launch').addEventListener('click', () => {
            ballBody.velocity.set(
                (Math.random() - 0.5) * 10,
                15,
                (Math.random() - 0.5) * 10
            );
        });

        document.getElementById('reset').addEventListener('click', () => {
            ballBody.position.set(levelCenter.x, levelCenter.y + 8, levelCenter.z);
            ballBody.velocity.set(0, 0, 0);
            ballBody.angularVelocity.set(0, 0, 0);
        });

        // Level selector
        document.querySelectorAll('#selector button').forEach(btn => {
            btn.addEventListener('click', () => {
                loadLevel(btn.dataset.level);
            });
        });

        // Animation
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            
            if (levelLoaded) {
                const delta = clock.getDelta();
                world.step(1/60, delta, 3);
                
                ball.position.copy(ballBody.position);
                ball.quaternion.copy(ballBody.quaternion);
                
                const targetCamPos = new THREE.Vector3(
                    ball.position.x + 8,
                    ball.position.y + 5,
                    ball.position.z - 10
                );
                camera.position.lerp(targetCamPos, 0.02);
                camera.lookAt(ball.position);
            }
            
            renderer.render(scene, camera);
        }

        // Init
        initScene();
        loadLevel('spiral_v2'); // Start with v2
        animate();
    </script>
</body>
</html>
