/**
 * Module d'encodage vidéo avec FFmpeg
 * Assemble frames + audio en MP4 TikTok-ready
 */

import { spawn } from 'child_process';
import { join } from 'path';
import Logger from '../utils/logger.js';
import CONFIG from '../config.js';
import retry from '../utils/retry.js';
import { fileExists } from '../utils/fsx.js';

const logger = new Logger('ENCODE');

/**
 * Encode les frames en vidéo MP4 avec audio
 * @param {string} framesDir - Dossier contenant les frames PNG
 * @param {string} audioPath - Chemin du fichier audio
 * @param {string} outputPath - Chemin de sortie MP4
 * @returns {Promise<string>} - Chemin du fichier généré
 */
export async function encodeVideo(framesDir, audioPath, outputPath) {
  logger.info(`Encodage vidéo: ${outputPath}`);

  // Vérifications
  if (!fileExists(framesDir)) {
    throw new Error(`Dossier frames introuvable: ${framesDir}`);
  }

  if (!fileExists(audioPath)) {
    throw new Error(`Fichier audio introuvable: ${audioPath}`);
  }

  const ffmpegPath = CONFIG.ffmpeg.path;
  const fps = CONFIG.video.fps;
  const width = CONFIG.video.width;
  const height = CONFIG.video.height;

  // Pattern de frames: frame_0001.png, frame_0002.png, etc.
  const framePattern = join(framesDir, 'frame_%04d.png');

  // Construction de la commande FFmpeg
  const args = [
    '-y',  // Overwrite
    '-framerate', fps.toString(),
    '-i', framePattern,
    '-i', audioPath,
    
    // Vidéo
    '-c:v', CONFIG.video.codec,
    '-preset', CONFIG.video.preset,
    '-crf', CONFIG.video.crf.toString(),
    '-pix_fmt', CONFIG.video.pixelFormat,
    
    // Audio
    '-c:a', CONFIG.audio.codec,
    '-b:a', CONFIG.audio.bitrate,
    '-ar', CONFIG.audio.sampleRate.toString(),
    
    // Synchronisation
    '-shortest',  // Fin au plus court (audio ou vidéo)
    
    // Métadonnées TikTok
    '-metadata', 'title=Generated by TikTok 3D Video Generator',
    '-metadata', 'comment=Auto-generated 3D music visualization',
    
    // Optimisations
    '-movflags', '+faststart',  // Streaming web
    '-profile:v', 'high',
    '-level', '4.2',
    
    outputPath,
  ];

  return retry(async () => {
    return new Promise((resolve, reject) => {
      const process = spawn(ffmpegPath, args, {
        stdio: ['ignore', 'pipe', 'pipe'],
      });

      let stderr = '';

      process.stderr.on('data', (data) => {
        stderr += data.toString();
        // Log progression FFmpeg
        const progressMatch = data.toString().match(/frame=\s*(\d+)/);
        if (progressMatch) {
          const frame = parseInt(progressMatch[1]);
          if (frame % 30 === 0) {
            logger.debug(`Encodage frame ${frame}`);
          }
        }
      });

      process.on('close', (code) => {
        if (code !== 0) {
          logger.error('FFmpeg stderr:', stderr.slice(-500));
          reject(new Error(`FFmpeg échoué (code ${code})`));
        } else {
          if (!fileExists(outputPath)) {
            reject(new Error('Fichier MP4 non créé'));
          } else {
            logger.success(`Vidéo générée: ${outputPath}`);
            resolve(outputPath);
          }
        }
      });

      process.on('error', (error) => {
        reject(new Error(`Erreur spawn FFmpeg: ${error.message}`));
      });
    });
  }, {
    maxAttempts: 2,
    delayMs: 2000,
  });
}

/**
 * Obtient les infos d'une vidéo
 */
export async function getVideoInfo(videoPath) {
  const ffprobePath = CONFIG.ffmpeg.path.replace('ffmpeg', 'ffprobe');

  return new Promise((resolve, reject) => {
    const args = [
      '-v', 'error',
      '-show_entries', 'format=duration,size',
      '-show_entries', 'stream=width,height,codec_name',
      '-of', 'json',
      videoPath,
    ];

    const process = spawn(ffprobePath, args, {
      stdio: ['ignore', 'pipe', 'pipe'],
    });

    let stdout = '';
    let stderr = '';

    process.stdout.on('data', (data) => {
      stdout += data.toString();
    });

    process.stderr.on('data', (data) => {
      stderr += data.toString();
    });

    process.on('close', (code) => {
      if (code !== 0) {
        reject(new Error(`ffprobe échoué: ${stderr}`));
      } else {
        try {
          const info = JSON.parse(stdout);
          resolve(info);
        } catch (error) {
          reject(new Error(`Parse ffprobe échoué: ${error.message}`));
        }
      }
    });
  });
}

export default encodeVideo;
